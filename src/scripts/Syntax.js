// Generated by CoffeeScript 1.10.0
var analyze, calcSelect, checkLL1, gen_table, isNullable, isTerminal, rules, symbols,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

rules = symbols = null;

(function() {
  var grammer, i, j, k, len, len1, m, ref, x;
  grammer = "Program -> Declaration Program\nDeclaration -> FunctionDef\nDeclaration -> RecordDef\nFunctionDef -> Type ID SLP ArgList SRP LLP Statements LRP\nRecordDef -> ID LLP Statements LRP\nArgList -> ε\nArgList -> VarDef ArgList_tail\nArgList_tail -> ε\nArgList_tail -> COMMA VarDef ArgList_tail\nVariable -> ID IndexList\nIndexList -> ε\nIndexList -> Index IndexList\nIndex -> MLP Expression MRP\nVarDef -> Type Variable\nStatements -> ε\nStatements -> Statement Statements\nStatement -> LLP Statements LRP\nStatement -> VarDef LF\nStatement -> Variable EQ Expression LF\nStatement -> WHILE SLP Expression SRP Statement\nStatement -> IF SLP Expression SRP Statement Statement_else\nStatement_else -> ε\nStatement_else -> ELSE Statement\nStatement -> Variable SLP VarList SRP LF\nVarList -> ε\nVarList -> Variable VarList_tail\nVarList_tail -> ε\nVarList_tail -> COMMA Variable VarList_tail\nExpression -> Expression_atom Expression_tail\nExpression_tail -> ε\nExpression_tail -> OP Expression_atom Expression_tail\nExpression_atom -> SLP Expression SRP\nExpression_atom -> Variable\nExpression_atom -> CONST\nExpression_atom -> Variable SLP VarList SRP\nCONST -> INTC\nCONST -> FLOATC\nCONST -> STRINGC\nCONST -> CHARC\nType -> INT\nType -> FLOAT\nType -> BOOL\nType -> STRING\nType -> CHAR\nType -> RECORD ID";
  rules = (function() {
    var k, len, ref, results;
    ref = grammer.split('\n');
    results = [];
    for (i = k = 0, len = ref.length; k < len; i = ++k) {
      x = ref[i];
      results.push({
        left: x.split('->')[0].trim(),
        right: x.split('-> ')[1].split(' ').map(function(x) {
          return x.trim();
        }),
        id: i
      });
    }
    return results;
  })();
  symbols = new Set;
  for (k = 0, len = rules.length; k < len; k++) {
    i = rules[k];
    symbols.add(i.left);
    ref = i.right;
    for (m = 0, len1 = ref.length; m < len1; m++) {
      j = ref[m];
      symbols.add(j);
    }
  }
  return symbols["delete"]('ε');
})();

calcSelect = function() {
  var calcFirst, calcFollow, i, k, len, results, x;
  calcFirst = (function() {
    var cache;
    cache = {};
    (function() {
      var allSeq, counter, flag, i, left, results, right, rule, t;
      allSeq = _.groupBy(rules, function(x) {
        return x.left;
      });
      symbols.forEach(function(i) {
        if (isTerminal(i)) {
          return cache[i] = [i];
        } else {
          return cache[i] = indexOf.call(_.chain(allSeq[i]).pluck('right').flatten().value(), 'ε') >= 0 ? ['ε'] : [];
        }
      });
      flag = true;
      results = [];
      while (flag) {
        flag = false;
        results.push((function() {
          var k, len, len1, len2, m, n, ref, results1;
          results1 = [];
          for (k = 0, len = rules.length; k < len; k++) {
            rule = rules[k];
            left = rule.left, right = rule.right;
            counter = 0;
            for (m = 0, len1 = right.length; m < len1; m++) {
              i = right[m];
              if (i === 'ε') {
                continue;
              }
              ref = cache[i];
              for (n = 0, len2 = ref.length; n < len2; n++) {
                t = ref[n];
                if (t !== 'ε' && indexOf.call(cache[left], t) < 0) {
                  cache[left].push(t);
                  flag = true;
                }
              }
              if (indexOf.call(cache[i], 'ε') < 0) {
                break;
              }
              counter += 1;
            }
            if (counter === right.length && indexOf.call(cache[left], 'ε') < 0) {
              cache[left].push('ε');
              results1.push(flag = true);
            } else {
              results1.push(void 0);
            }
          }
          return results1;
        })());
      }
      return results;
    })();
    return function(x) {
      var flag, i, j, k, l, len, len1, m, ref, result;
      if (cache[x] != null) {
        return cache[x];
      }
      if (!x.length || x === 'ε') {
        return ['ε'];
      }
      l = x.split('-');
      result = [];
      flag = true;
      for (k = 0, len = l.length; k < len; k++) {
        i = l[k];
        ref = calcFirst(i);
        for (m = 0, len1 = ref.length; m < len1; m++) {
          j = ref[m];
          if (j !== 'ε') {
            result.push(j);
          }
        }
        if (indexOf.call(calcFirst(i), 'ε') < 0) {
          flag = false;
          break;
        }
      }
      if (flag) {
        result.push('ε');
      }
      return cache[x] = result;
    };
  })();
  calcFollow = (function() {
    var cache;
    cache = {};
    (function() {
      var allSeq, beta, flag, i, k, left, len, results, right, rule, x;
      allSeq = _.groupBy(rules, function(x) {
        return x.left;
      });
      for (k = 0, len = rules.length; k < len; k++) {
        rule = rules[k];
        if (!cache[rule.left]) {
          cache[rule.left] = [];
        }
      }
      cache['Program'] = ['$'];
      flag = true;
      results = [];
      while (flag) {
        flag = false;
        results.push((function() {
          var len1, m, results1;
          results1 = [];
          for (m = 0, len1 = rules.length; m < len1; m++) {
            rule = rules[m];
            left = rule.left, right = rule.right;
            results1.push((function() {
              var len2, len3, n, o, p, ref, ref1, ref2, results2;
              results2 = [];
              for (i = n = ref = right.length - 1; ref <= 0 ? n <= 0 : n >= 0; i = ref <= 0 ? ++n : --n) {
                if (right[i] === 'ε' || isTerminal(right[i])) {
                  continue;
                }
                beta = right.slice(i + 1).join('-');
                ref1 = calcFirst(beta);
                for (o = 0, len2 = ref1.length; o < len2; o++) {
                  x = ref1[o];
                  if (x === 'ε') {
                    ref2 = cache[left];
                    for (p = 0, len3 = ref2.length; p < len3; p++) {
                      x = ref2[p];
                      if (indexOf.call(cache[right[i]], x) < 0) {
                        cache[right[i]].push(x);
                        flag = true;
                      }
                    }
                  } else {
                    if (indexOf.call(cache[right[i]], x) < 0 && x !== 'ε') {
                      cache[right[i]].push(x);
                      flag = true;
                    }
                  }
                }
                if (i + 1 < right.length && indexOf.call(calcFirst(right[i + 1]), 'ε') < 0) {
                  break;
                } else {
                  results2.push(void 0);
                }
              }
              return results2;
            })());
          }
          return results1;
        })());
      }
      return results;
    })();
    return function(x) {
      if (cache[x] != null) {
        return cache[x];
      }
      throw new Error("TODO");
    };
  })();
  window.calcFirst = calcFirst;
  window.calcFollow = calcFollow;
  results = [];
  for (k = 0, len = rules.length; k < len; k++) {
    i = rules[k];
    if (indexOf.call(calcFirst(i.right.join('-')), 'ε') < 0) {
      results.push(i.select = calcFirst(i.right.join('-')));
    } else {
      i.select = calcFirst(i.right.join('-'));
      i.select = _(i.select).without('ε');
      results.push((function() {
        var len1, m, ref, results1;
        ref = calcFollow(i.left);
        results1 = [];
        for (m = 0, len1 = ref.length; m < len1; m++) {
          x = ref[m];
          results1.push(i.select.push(x));
        }
        return results1;
      })());
    }
  }
  return results;
};

checkLL1 = function() {
  throw new Error("TODO");
};

gen_table = function() {
  var i, k, len, len1, m, ref, rule, table;
  table = {};
  for (k = 0, len = rules.length; k < len; k++) {
    rule = rules[k];
    if (!table[rule.left]) {
      table[rule.left] = {};
    }
    ref = rule.select;
    for (m = 0, len1 = ref.length; m < len1; m++) {
      i = ref[m];
      table[rule.left][i] = rule;
    }
  }
  return table;
};

analyze = function(tokens) {
  var X, i, ip, queue, results, stack, table;
  ip = tokens.shift();
  stack = ['$', 'Program'];
  X = 'Program';
  table = gen_table();
  console.log(table);
  results = [];
  while (X !== '$') {
    console.log(X);
    if (X === ip.type) {
      ip = tokens.shift();
      stack.pop();
    } else if (isTerminal(X)) {
      console.error('unexpected terminal');
    } else if (X === 'ε') {
      stack.pop();
    } else {
      if (table[X][ip.type]) {
        console.log(table[X][ip.type]);
        stack.pop();
        queue = (function() {
          var k, len, ref, results1;
          ref = table[X][ip.type].right;
          results1 = [];
          for (k = 0, len = ref.length; k < len; k++) {
            i = ref[k];
            results1.push(i);
          }
          return results1;
        })();
        while (queue.length) {
          stack.push(queue.pop());
        }
      } else {
        if (ip.type === 'LF') {
          ip = tokens.shift();
        } else if ('ε') {
          console.error("unexpected " + ip.type);
          break;
        }
      }
    }
    results.push(X = stack[stack.length - 1]);
  }
  return results;
};

isTerminal = function(x) {
  return x === x.toUpperCase() && x !== 'ε';
};

isNullable = (function() {
  var cache;
  cache = {};
  return function(x) {
    if (cache[x]) {
      return cache[x];
    }
    console.log(rules.filter(function(x) {
      return x.left === x;
    }));
    return cache[x] = rules.filter(function(x) {
      return x.left === x;
    }).filter(function(x) {
      return indexOf.call(x.right, 'ε') >= 0;
    }).length;
  };
})();

window.Syntax = {
  rules: rules,
  symbols: symbols,
  analyze: analyze,
  isNullable: isNullable
};

calcSelect();
